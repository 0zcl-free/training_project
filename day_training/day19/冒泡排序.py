
def bubble(array):
    for i in range(len(array)-1):
        for j in range(len(array)-1-i):
            if array[j] > array[j+1]:  # 如果前一个大于后一个，则交换
                temp = array[j]
                array[j] = array[j+1]
                array[j+1] = temp


if __name__ == "__main__":
    array = [265, 494, 302, 160, 370, 219, 247, 287,
             354, 405, 469, 82, 345, 319, 83, 258, 497, 423, 291, 304]
    print("------->排序前<-------")
    print(array)
    bubble(array)
    print("------->排序后<-------")
    print(array)


"""
讲解:
以随机产生的五个数为列:li = [354, 405, 469, 82, 345]
冒泡排序是怎么实现的?
首先先来个大循环，每次循环找出最大的数，放在列表的最后面。在上面的例子中，第一次找出最大数469，将469放在最后一个，此时我们知道
列表最后一个肯定是最大的，故还需要再比较前面4个数，找出4个数中最大的数405，放在列表倒数第二个......
5个数进行排序，需要多少次的大循环??　当然是4次啦! 同理，若有n个数，需n-1次大循环。
现在你会问我: 第一次找出最大数469，将469放在最后一个?? 怎么实现的??
嗯，（在大循环里）用一个小循环进行两数比较，首先354与405比较，若前者较大，需要交换数；反之不用交换。
当469与82比较时，需交换，故列表倒数第二个为469；469与345比较，需交换，此时最大数469位于列表最后一个啦!
难点来了，小循环需要多少次??
如果每次进行两数比较，从列表头比较至列表尾，此时需len(array)-1次!!, 但是，举个例子吧:当大循环i为3时，
说明此时列表的最后3个数已经排好序了，不必进行两数比较，故小循环需len(array)-1-3.　即len(array)-1-i
"""